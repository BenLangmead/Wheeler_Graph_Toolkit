# Wheeler_Graph

## Recognizer

WG recognizing problem is hard. It is proved NP-complete by Gibney and Thankachan in 2019, and the time complexity of the pseudocode algorithm is <img src="https://render.githubusercontent.com/render/math?math=2^{e \cdot log\sigma  %2B O(n  %2B e)}">.
We implemented a faster recognizer in C++, and it is a factorial algorithm doing minimum permutations. Given a directed graph G with edge labels and random node labels in DOT format, the recognizer answers whether G is a wheeler graph or not and outputs the WG data structure proposed by Gagie (2017). 


### 1. Building the latest version from `src/`

* Compiling permutation algorithm
```
cd ./permutation_algorithm/src/

make
```

* Compiling Gibney's and Thankachan's exponential algorithm
```
cd ./exponential_algorithm/src/

make
```

---

### 2. Running recognizer_p

```
Usage:

	recognizer_p <in.dot> [--version] [-h / --help] [-v / --verbose] [-o / --outDir] [-s / --solver <smt / p>] [-w / --writeIOL] [-r / --writeRange] [-i / --label_is_int] [-b / --benchmark] [-e / --exhaustive_search] [-f / --full_range_search]
	
Options:

   version           : print out the current version (0.1.0)
  
   help              : print out the usage message.
   
   verbose	     : run in the verbose mode.
                         
   outDir            : The directory for the files to be outputed.
                          
   solver            : Specify which solver the user would like to run with. Default is `SMT`, and you can input either `SMT` or `p`.
   
   writeIOL          : Output the I, O, L three-bitarray data structure proposed by Gagie et al. 
   
   writeRange        : Output the range information produce by the renaming heuristic. 
   
   label_is_int      : Specifiy if the edge labels of your input graph are integer. The edge labels are treated as strings by default.
   
   benchmark         : Run the recognizer in `benchmark mode`.  Four columns are outputed which are 'if the input graph is Wheeler', 'number of nodes', 'runtime in microseconds', and 'path to the input graph'
   
   exhaustive_search : Run the recongizer in `exhaustive search mode`. The solver is set to `p` when this option is provided.
   
   full_range_search : Run the recognizer in `full range search mode`. The renaming heuristic is skipped, and the recognizer searches the whole search space using the solver (`SMT` or `p`) the user specified.
```

#### 2.1 Inputs and outputs:
The recognizer_p takes any DOT file as the input and test whether at least one set of correct node labels can be generated. In this WG suite of tools, it takes the DOT file generated by generator. If it is not a WG, program halts and nothing is outputted; if it is a wheeler, then five files are generated. Following are the description:

1. `I.txt`:  the I bitarray (indegree) of Gagie's WG data structure.
2. `O.txt`:  the O bitarray (outdegree) of Gagie's WG data structure.
3. `L.txt`:  the L array of Gagie's WG data structure.. It’s the concatenation of corresponding edges labels of nodes in O bit array.
4. `node.dot`: the mapping from old node labels to new node labels.  
5. `graph.dot`: the new, correct, and sorted dot file with new node labels. 


#### 2.2 Reproducible example:

Take `./graph/generator_DOT/node_num_5/after_shuffle/test_1.dot` DOT file as an example. It is a random valid WG outputted by the generator, and recognizer takes it as the input.

```
DOT file path:  ./graph/example.dot

   strict digraph  {
   S1;
   S0;
   S5;
   S3;
   S6;
   S2;
   S4;
   S5 -> S0  [label=a];
   S5 -> S6  [label=a];
   S5 -> S4  [label=b];
   S3 -> S4  [label=b];
   S4 -> S6  [label=a];
   }
 ```
  
Run the following command:

```
	./bin/recognizer  ./graph/example.dot
```

This is what you will see in the terminal:
```
(v) solved by permutation
(v) It is a wheeler graph!!
Runtime : 964 microseconds
```
<!-- 
You will get the following five output files:

	1. ***I.txt***:
```
	    1101001001
```
	2. ***O.txt***:
```
	    0100011101
```
	3. ***L.txt***:
```
	    baaba
```
	4. ***node.dot***:
```
	    S3	1
	    S5	2
	    S0	3
	    S6	4
	    S4	5
```
	5. ***graph.dot***:
```
	    strict digraph  {
	    2 -> 3 [label=a];
	    2 -> 4 [label=a];
	    5 -> 4 [label=a];
	    1 -> 5 [label=b];
	    2 -> 5 [label=b];
	    }
```
---

### 3. Running recognizer_e

```
Usage:

	recognizer_e <in.dot> [--version] [-h / --help] [-v / --verbose]
	
Options:

   version        : print out the current version (0.1.0)
  
   help           : print out the usage message.
   
   verbose	  : run in the verbose mode.
```

#### 2.1 Inputs and outputs:
It is an implementation of Gibney's and Thankachan's exponential algorithm to the point of enumerating 3 bit arrays (`|I|`, `|O|`, `|L|`). The recognizer_e takes any DOT file as the input.

1. `I.txt`:  the I bitarray (indegree) of Gagie's WG data structure.
2. `O.txt`:  the O bitarray (outdegree) of Gagie's WG data structure.
3. `L.txt`:  the L array of Gagie's WG data structure.. It’s the concatenation of corresponding edges labels of nodes in O bit array.
4. `node.dot`: the mapping from old node labels to new node labels.  
5. `graph.dot`: the new, correct, and sorted dot file with new node labels. 


#### 2.2 Reproducible example:

Take `./graph/generator_DOT_small/node_num_3/after_shuffle/test_1.dot` DOT file as an example. It is a random valid WG outputted by the generator, and recognizer takes it as the input.

```
DOT file path:  ./graph/generator_DOT_small/node_num_3/after_shuffle/test_1.dot

	strict digraph  {
	S3;
	S1;
	S5;
	S6;
	S0;
	S2;
	S4;
	S3 -> S1  [label=a];
	S5 -> S6  [label=b];
	S0 -> S4  [label=b];
	S2 -> S3  [label=a];
	}
 ```
  
Run the following command:

```
	./bin/recognizer_e  ./graph/generator_DOT_small/node_num_3/after_shuffle/test_1.dot
```

This is what you will see in the terminal:

```
	*  |E|: 4
	*  |N|: 7
	*  |σ|: 2
	*  σ encoding length: 1
	*  σ encoding mapping:
		a: 0
		b: 1

	*  |I|: 11 (4 + 7)
	*  I bitvector:
		11101010101

	*  |O|: 11 (4 + 7)
	*  O bitvector:
		01010110111

	*  |L_char|: 4 (4)
	*  L vector:
		baba

	*  |L|: 4 (4 x 1)
	*  L bitvector:
		1010

	*  Total number of iteration times (without filteration): 2^|I| * 2^|O| * 2^|L| (2048 * 2048 * 16): 6.71089e+07

	Iterating through 3 bit arrays:
	Runtime : 3042 microseconds
```
 -->
